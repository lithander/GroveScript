***PRODUCTIONS***

Productions are what makes Grove script unique. The idea is taken from L-Systems (http://en.wikipedia.org/wiki/L-system) a string rewriting system that allows us to generate a complex command flow from a simple script. 

Productions act on strings of sequence-names generating longer strings of sequence names.
Let's look at the Koch Snowflake example to see what that means:

You can group commands and give these group a name. That's what we call a sequence-name:

For the Koch Snowflake we need only 3 very basic sequences: 

	#+
	rotate 60
	#-
	rotate -60
	#A
	move 1

Now you could run any of the sequence by referring to their name. (+, -, A)

	run A
	run +
	run +
	run A
	run +
	run +
	run A

In this example not much is gained over just writing the commands directly. But if the sequences were longer (contain more commands) it could be benefitial to run a sequence like that. 
But sequences are not where it stops. Now let's explore some possiblities that are unique to Grove Script as opposed to 'normal' procedural languages.

For one, we can express the above by the following 2 lines.

	seed frac, A + + A + + A
	run frac

The 'Seed' command defines a string of sequence names. The run command, when passed such a string executes all sequences one after another.

And this leads us to productions. We can use productions to grow a string of sequence names. Here's a rule. 

	#rule
	A -> A - A + + A - A

It says "Repelace each 'A' you find with 'A - A + + A - A'". The sub-string the rule looks for in the input string is called predecessor and what it becomes in the output string is called the successor.

'rule' applied to the content 'frac' would transform it from transform frac from containing

	A + + A + + A  becomes  A - A + + A - A + + A - A + + A - A + + A - A + + A - A

 To invoke that kind of transformation the 'Grow' command can be used.

	grow frac, rules
	
Typically you'd define a simple string to start with (called axiom) and then apply production rules until you got a fancy complex string, which when executed produce quite complex output.


**Precedence of Rules**

A production can define multiple rules.

	#rules
	A -> B - A - B
	B -> A + B + A

Scanning the input string left to right, token for token, all rules are checked for compliance, top to bottom. The first rule where the input pattern fits is chosen.

**Context**

Just like the successor the predecessor can require multiple tokens to match. If you want to change A into C only if it is followed by B just include B in the predeccesor AND successor and it will be required but not changed.

A B -> C B

**Conditions**

For a rule to qualify you can add an additional arbitrary requirement as a boolean-expression seperated with ':' from the predecessor. In the "Random Foo" example you'll find this production:

	#ResolveFoo
	Foo : rnd() > 0.6 -> Red Base
	Foo : rnd() < 0.3 -> Green Base
	Foo -> Blue Base
	
All three rules have the same predecessor. When Foo is encountered in the input string they'd all qualify. But as they are checked top to bottom for compliance and the first two have additional conditions those conditions have to evaluate to 'true', too, before a rule can be applied.
As the rnd() function returns a random number between 0 and 1 the first rule has only a chance of 40% to be chosen. If it's not chosen there's a 30% chance to chose the second rule. If neither the first nor the second rule are taken the third will always fit. Effectively this production replaces Foo with either Red, Blue or Green followed always by Base. What is chosen where is random. (Or pseudo-random, because the sequence of numbers generated by rnd() is predetermined and can be set using the 'Shuffle' command.)

**Consequences**

There's another feature to spice up productions. You can specify a sequence of commands to be executed whenever a production-rule is applied. Just add a block of code attached to the definition of a rule.

Here's another variant of #ResolveFoo this time the result isn't random anymore. Instead there's a variable that will be changed everytime a rule is taken and which state determines the next rule that will activate.

#ResolveFoo
Foo : i = 0 -> Red Base
	raise i
Foo : i = 1 -> Green Base
	raise i
Foo -> Blue Base
	set i, 0

When we initialize i with 0 the first time #ResolveFoo finds a Foo the first rule qualifies. This will replace "Foo" with "Red Base". But it also raises i. So the next time the 2nd rule qualifies (it's condition requires i to be 1) raising i again to 2. Neither the first nor the second rule accept i anymore, so when the next "Foo" is encountered the third rule applys, setting i back to 0. So the three rules will be chosen cyclic, one after another.

**Parameters**

Last but not least tokens can have parameters attached to them.

A -> B(1, 3)

The above rule will take any A (with parameters or none) and replace them by B with two parametric values.
It is possible to modify existing parameters by using variable names in rules like this:

C(i, j) -> C(i+1, j-1)

Rules can require specific parameter values by using parameter variables in conjunction with conditions.

A(x) : y > 3 and x < 5 -> B(0)

The above would transform A(4) into B(0) but leave all others untouched.

Parameters not only help rules to become more flexible, they can also be used in the sequence that is associated with the token.

#sum(a, b)
out a+b

run sum(3, 2)

In the above script we use the parameters 3 and 2 are passed into the local variables a and b of sequence 'sum' where they can be used just like global variables.We would see 5 printed on the screen.
